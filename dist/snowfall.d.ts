// Generated by dts-bundle-generator v9.5.1

declare function allocate_memory(size: number): number;
declare function free_memory(ptr: number, size: number): void;
declare function lexer(source: string): any;
declare function main_init(): void;
declare function version(): string;
export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;
export interface InitOutput {
	readonly memory: WebAssembly.Memory;
	readonly main_init: () => void;
	readonly allocate_memory: (a: number) => number;
	readonly free_memory: (a: number, b: number) => void;
	readonly version: () => [
		number,
		number
	];
	readonly lexer: (a: number, b: number) => [
		number,
		number,
		number
	];
	readonly __wbindgen_malloc: (a: number, b: number) => number;
	readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
	readonly __wbindgen_free: (a: number, b: number, c: number) => void;
	readonly __wbindgen_externrefs: WebAssembly.Table;
	readonly __externref_table_dealloc: (a: number) => void;
	readonly __wbindgen_start: () => void;
}
export type SyncInitInput = BufferSource | WebAssembly.Module;
declare function initSync(module: {
	module: SyncInitInput;
} | SyncInitInput): InitOutput;
declare function __wbg_init(module_or_path?: {
	module_or_path: InitInput | Promise<InitInput>;
} | InitInput | Promise<InitInput>): Promise<InitOutput>;
export interface Span {
	start: number;
	end: number;
}
export type LiteralToken = {
	type: "Int" | "Float";
	value: number;
} | {
	type: "String";
	value: String;
} | {
	type: "Boolean";
	value: Boolean;
};
export type OperatorToken = {
	type: "Assign" | "Equal" | "StrictEqual" | "Plus" | "Minus" | "Asterisk" | "Power" | "Slash" | "Percent" | "Bang" | "NotEqual" | "StrictNotEqual" | "LessThan" | "LessThanOrEqual" | "GreaterThan" | "GreaterThanOrEqual" | "LogicalAnd" | "LogicalOr" | "BitwiseAnd" | "BitwiseOr" | "BitwiseXor" | "BitwiseNot" | "BitwiseLeftShift" | "BitwiseUnsignedLeftShift" | "BitwiseRightShift" | "BitwiseUnsignedRightShift";
};
export type DelimiterToken = {
	type: "Dot" | "Comma" | "Colon" | "Semicolon" | "LParen" | "RParen" | "LBrace" | "RBrace" | "LBracket" | "RBracket";
};
export type KeywordToken = {
	type: "Function" | "Sub" | "Class" | "Extends" | "Constructor" | "New" | "If" | "Else" | "For" | "While" | "In" | "Of" | "Switch" | "Case" | "Default" | "Break" | "Continue" | "Return" | "True" | "False" | "Null" | "And" | "Or";
};
export type TokenKind = {
	type: "Eof";
} | {
	type: "Illegal" | "Identifier";
	value: string;
} | {
	type: "Literal";
	value: LiteralToken;
} | {
	type: "Operator";
	value: OperatorToken;
} | {
	type: "Delimiter";
	value: DelimiterToken;
} | {
	type: "Keyword";
	value: KeywordToken;
};
export interface Token {
	kind: TokenKind;
	span: Span;
}
export type WasmModule = typeof wasm & {
	memory: WebAssembly.Memory;
};
export declare class SnowFall {
	private _isDebug;
	private _wasm;
	private _isInitialized;
	constructor(isDebug?: boolean);
	init(wasmPath: string | ArrayBuffer | NonSharedBuffer): Promise<void>;
	ensureInitialized(): WasmModule;
	/**
	 * ts(js)ライブラリのバージョン取得
	 */
	version(): string;
	/**
	 * rust(wasm)ライブラリのバージョン取得
	 */
	version_wasm(): string;
	/**
	 * デバッグ用のLexer関数
	 * @param input ソースコードの文字列
	 * @returns トークンの配列
	 * @deprecated 開発・デバッグ用の関数です。本番環境では使用しないでください。
	 */
	dev_lexer(input: string): Array<Token>;
	private _logInfo;
}

declare namespace wasm {
	export { InitInput, InitOutput, SyncInitInput, __wbg_init as default, allocate_memory, free_memory, initSync, lexer, main_init, version };
}

export {};
